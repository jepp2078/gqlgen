{{ reserveImport "context"  }}
{{ reserveImport "errors"  }}
{{ reserveImport "fmt"  }}
{{ reserveImport "strings"  }}

{{ reserveImport "golang.org/x/sync/errgroup" }}
{{ reserveImport "github.com/99designs/gqlgen/plugin/federation/fedruntime" }}

func (ec *executionContext) __resolve__service(ctx context.Context) (fedruntime.Service, error) {
	if ec.DisableIntrospection {
		return fedruntime.Service{}, errors.New("federated introspection disabled")
	}

	var sdl []string

	for _, src := range sources {
		if src.BuiltIn {
			continue
		}
		sdl = append(sdl, src.Input)
	}

	return fedruntime.Service{
		SDL: strings.Join(sdl, "\n"),
	}, nil
}

{{if .Entities}}
func (ec *executionContext) __resolve_entities(ctx context.Context, representations []map[string]interface{}) ([]fedruntime.Entity, error) {
	list := make([]fedruntime.Entity, len(representations))
	resolveEntity := func(ctx context.Context, i int, rep map[string]interface{}) error {
		typeName, ok := rep["__typename"].(string)
		if !ok {
			return errors.New("__typename must be an existing string")
		}
		switch typeName {
		{{ range .Entities }}
			{{ if .ResolverName }}
			case "{{.Def.Name}}":
				{{ range $i, $keyField := .KeyFields -}}
					id{{$i}}, err := ec.{{.TypeReference.UnmarshalFunc}}(ctx, rep["{{$keyField.Field.Name}}"])
					if err != nil {
						return errors.New(fmt.Sprintf("Field %s undefined in schema.", "{{$keyField.Field.Name}}"))
					}
				{{end}}
	
				entity, err := ec.resolvers.Entity().{{.ResolverName | go}}(ctx,
					{{ range $i, $_ := .KeyFields -}} id{{$i}}, {{end}})
				if err != nil {
					return err
				}
	
				{{ range .Requires }}
					{{ range .Fields}}
						entity.{{.NameGo}}, err = ec.{{.TypeReference.UnmarshalFunc}}(ctx, rep["{{.Name}}"])
						if err != nil {
							return err
						}
					{{ end }}
				{{ end }}
                list[i] = entity
				return nil
			{{ end }}
		{{ end }}
		default:
			return errors.New("unknown type: "+typeName)
		}
	}

	// if there are multiple entities to resolve, parallelize (similar to
	// graphql.FieldSet.Dispatch)
	switch len(representations) {
	case 0:
		return list, nil
	case 1:
		err := resolveEntity(ctx, 0, representations[0])
		return list, err
	default:
		eg, gCtx := errgroup.WithContext(ctx)
		for i, rep := range representations {
			i, rep := i, rep
			eg.Go(func() error { return resolveEntity(gCtx, i, rep) })
		}
		err := eg.Wait()
		if err != nil {
			return nil, err
		}
		return list, nil
	}
}
{{end}}